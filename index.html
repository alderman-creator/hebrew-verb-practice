<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hebrew Bible Verb Practice</title>
<style>
:root {
  --bg0: #f1efe6;
  --bg1: #e5dfcf;
  --card: #fffdf7;
  --ink: #222018;
  --muted: #655f50;
  --line: #d7ceba;
  --brand: #255f5a;
  --brand-2: #1e4f4b;
  --ok: #d7f0dd;
  --bad: #f7d4d4;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  min-height: 100vh;
  color: var(--ink);
  font-family: "Alegreya Sans", "Trebuchet MS", "Gill Sans", sans-serif;
  background:
    radial-gradient(circle at 80% 20%, rgba(37,95,90,0.16) 0, rgba(37,95,90,0) 40%),
    radial-gradient(circle at 20% 80%, rgba(175,141,72,0.16) 0, rgba(175,141,72,0) 42%),
    linear-gradient(180deg, var(--bg0), var(--bg1));
  padding: 20px;
}
.shell { max-width: 820px; margin: 0 auto; }
.card {
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 18px;
  padding: 20px;
  box-shadow: 0 12px 28px rgba(35, 30, 20, 0.08);
}
.hidden { display: none; }
h1 { margin: 6px 0 6px; font-size: 34px; line-height: 1.08; }
.sub { margin: 0 0 18px; color: var(--muted); }
.progress {
  display: inline-flex;
  border: 1px solid var(--line);
  border-radius: 999px;
  padding: 4px;
  gap: 5px;
  margin-bottom: 18px;
}
.progress span {
  width: 34px;
  height: 9px;
  border-radius: 99px;
  background: #e5ddca;
}
.progress span.on { background: var(--brand); }
.question { font-size: 26px; margin: 8px 0 16px; }
.chips { display: flex; flex-wrap: wrap; gap: 10px; }
button {
  border: 1px solid #baa983;
  background: #fffef8;
  color: var(--ink);
  border-radius: 11px;
  padding: 10px 13px;
  font-size: 15px;
  cursor: pointer;
  font-family: inherit;
}
button.active {
  background: var(--brand);
  color: #fff;
  border-color: var(--brand);
}
button.primary {
  background: var(--brand);
  color: #fff;
  border-color: var(--brand);
}
button.primary:hover { background: var(--brand-2); }
button[disabled] { opacity: 0.5; cursor: not-allowed; }
.nav { margin-top: 18px; display: flex; justify-content: space-between; gap: 10px; }
.note { min-height: 22px; margin-top: 10px; color: var(--muted); }
.kv { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
.kv span {
  font-size: 12px;
  padding: 5px 9px;
  border-radius: 999px;
  background: #eee8d9;
  color: #4d473b;
}
.toolbar { display: flex; justify-content: space-between; gap: 10px; align-items: center; margin-bottom: 8px; flex-wrap: wrap; }
.hebrew {
  font-size: clamp(44px, 10vw, 78px);
  text-align: center;
  margin: 14px 0 8px;
  line-height: 1.07;
}
.confirmation {
  min-height: 56px;
  border-radius: 12px;
  border: 1px solid var(--line);
  background: #f2efe6;
  font-size: 20px;
  padding: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  margin-bottom: 8px;
}
.confirmation.correct { background: var(--ok); }
.confirmation.incorrect { background: var(--bad); }
.feedback { min-height: 22px; text-align: center; color: var(--muted); margin-bottom: 14px; }
.section { margin-bottom: 14px; }
.section h3 { margin: 0 0 8px; font-size: 16px; }
.submit { width: 100%; margin-top: 10px; padding: 14px; font-size: 18px; }
.mobile-quiz { display: none; }
.compact-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 10px;
}
.compact-field label {
  display: block;
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 4px;
}
.compact-field select {
  width: 100%;
  padding: 8px;
  border-radius: 10px;
  border: 1px solid #baa983;
  background: #fffef8;
  color: var(--ink);
  font-size: 14px;
  font-family: inherit;
}
@media (max-width: 620px) {
  body { padding: 10px; }
  .card { padding: 14px; border-radius: 14px; }
  h1 { font-size: 24px; margin: 2px 0 8px; }
  .question { font-size: 20px; margin: 6px 0 10px; }
  .chips { gap: 8px; }
  button { padding: 8px 10px; font-size: 14px; }
  .toolbar { margin-bottom: 6px; }
  #wizardSummary { display: none; }
  #wizardNote { margin-top: 6px; min-height: 18px; font-size: 13px; }
  .nav {
    position: sticky;
    bottom: 0;
    background: var(--card);
    padding-top: 8px;
    padding-bottom: 2px;
    border-top: 1px solid var(--line);
    margin-top: 12px;
  }
  .section { display: none; }
  .mobile-quiz { display: block; }
  .hebrew { font-size: clamp(34px, 9vw, 52px); margin: 8px 0 6px; }
  .confirmation { min-height: 48px; font-size: 18px; padding: 9px; }
  .feedback { margin-bottom: 8px; min-height: 18px; }
  .submit {
    position: sticky;
    bottom: 0;
    margin-top: 6px;
    padding: 12px;
    border-radius: 12px;
  }
}
</style>
</head>
<body>
<div class="shell">
  <section id="setupView" class="card">
    <h1>Build Your Practice Session</h1>

    <h2 class="question" id="wizardQuestion"></h2>
    <div class="chips" id="wizardOptions"></div>
    <div class="toolbar">
      <button id="wizardSelectAllBtn" type="button">Select all</button>
      <button id="wizardClearBtn" type="button">Clear</button>
    </div>
    <div class="kv" id="wizardSummary"></div>
    <div class="note" id="wizardNote"></div>

    <div class="nav">
      <button id="backBtn" type="button">Back</button>
      <button id="nextBtn" class="primary" type="button">Next</button>
    </div>
  </section>

  <section id="quizView" class="card hidden">
    <div class="toolbar">
      <button id="changeSetupBtn" type="button">Change Setup</button>
      <div id="deckMeta" class="kv"></div>
    </div>

    <div id="hebrew" class="hebrew"></div>
    <div id="confirmation" class="confirmation">-</div>
    <div id="feedback" class="feedback"></div>

    <div class="mobile-quiz" id="mobileQuiz">
      <div class="compact-grid">
        <div class="compact-field"><label for="mobileStem">Stem</label><select id="mobileStem"></select></div>
        <div class="compact-field"><label for="mobileAspect">Aspect</label><select id="mobileAspect"></select></div>
        <div class="compact-field"><label for="mobilePerson">Person</label><select id="mobilePerson"></select></div>
        <div class="compact-field"><label for="mobileGender">Gender</label><select id="mobileGender"></select></div>
        <div class="compact-field"><label for="mobileNumber">Number</label><select id="mobileNumber"></select></div>
      </div>
    </div>

    <div class="section"><h3>Stem</h3><div class="chips" id="stem"></div></div>
    <div class="section"><h3>Aspect</h3><div class="chips" id="aspect"></div></div>
    <div class="section"><h3>Person</h3><div class="chips" id="person"></div></div>
    <div class="section"><h3>Gender</h3><div class="chips" id="gender"></div></div>
    <div class="section"><h3>Number</h3><div class="chips" id="number"></div></div>

    <button id="submitBtn" class="primary submit" type="button">Submit Parse</button>
  </section>
</div>

<script src="./hebrew_verbs_all_stems.js"></script>
<script src="./qal_strong_top100.js"></script>
<script>
const ROOT_LABELS = {
  strong: "Strong",
  i_nun: "1 Nun",
  i_wy: "1 Waw/Yod",
  hollow_ii_wy: "Hollow (II-W/Y)",
  iii_he: "III-He",
  other_weak: "Other Weak"
};
const STEM_ORDER = ["Qal", "Niphal", "Piel", "Pual", "Hiphil", "Hophal", "Hitpael"];
const ASPECT_ORDER = ["Perfect", "Imperfect", "Imperative", "Cohortative", "Jussive", "Infinitive", "Participle"];
const ROOT_ORDER = ["strong", "i_nun", "i_wy", "hollow_ii_wy", "iii_he", "other_weak"];

const app = {
  allRecords: [],
  options: { stem: [], aspect: [], verbType: [] },
  wizardStep: 0,
  wizardSelection: { stem: new Set(), aspect: new Set(), verbType: new Set() },
  deck: [],
  index: 0,
  answer: { stem: null, aspect: null, person: null, gender: null, number: null },
  dataReady: false
};

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function orderedExisting(order, values) {
  const set = new Set(values);
  const inOrder = order.filter(v => set.has(v));
  const extras = Array.from(set).filter(v => !order.includes(v)).sort((a, b) => a.localeCompare(b));
  return [...inOrder, ...extras];
}

function pgnKey(r) {
  return [r.person, r.gender, r.number].join("|");
}

function rebalanceByPGN(records) {
  const groups = new Map();
  for (const r of records) {
    const key = pgnKey(r);
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push(r);
  }
  const keys = Array.from(groups.keys());
  shuffle(keys);
  for (const key of keys) shuffle(groups.get(key));

  const out = [];
  let keep = true;
  while (keep) {
    keep = false;
    for (const key of keys) {
      const bucket = groups.get(key);
      if (bucket.length > 0) {
        out.push(bucket.pop());
        keep = true;
      }
    }
  }
  return out;
}

function parseCodeToFeatures(parseCode) {
  const m = /^p([123])-(sg|pl)-(m|f|unknown)$/.exec(parseCode);
  if (!m) return null;
  return {
    stem: "Qal",
    aspect: "Perfect",
    person: m[1],
    gender: m[3] === "m" ? "Masculine" : m[3] === "f" ? "Feminine" : "Common",
    number: m[2] === "sg" ? "Singular" : "Plural"
  };
}

function classifyVerbType(lexeme) {
  const root = (lexeme || "").replace(/[^A-Z<>]/g, "");
  if (!root) return "other_weak";
  if (root[0] === "N") return "i_nun";
  if (root[0] === "W" || root[0] === "J") return "i_wy";
  if (root[1] === "W" || root[1] === "J") return "hollow_ii_wy";
  if (root[2] === "H") return "iii_he";
  return "strong";
}

function buildRecordsFromLegacyTop100(data) {
  const uniqueByFormAndParse = new Map();
  const parseSetByForm = new Map();

  for (const [lexeme, lexData] of Object.entries(data || {})) {
    if (!lexData || typeof lexData !== "object") continue;
    const verbType = classifyVerbType(lexeme);

    for (const [parseCode, forms] of Object.entries(lexData)) {
      const features = parseCodeToFeatures(parseCode);
      if (!features || !Array.isArray(forms)) continue;
      const parseKey = [features.stem, features.aspect, features.person, features.gender, features.number].join("|");

      for (const rawForm of forms) {
        if (typeof rawForm !== "string") continue;
        const form = rawForm.trim();
        if (!form) continue;
        const dedupe = `${form}|||${parseKey}`;

        if (!uniqueByFormAndParse.has(dedupe)) {
          uniqueByFormAndParse.set(dedupe, {
            form,
            lexeme,
            verbType,
            stem: features.stem,
            aspect: features.aspect,
            person: features.person,
            gender: features.gender,
            number: features.number
          });
        }

        if (!parseSetByForm.has(form)) parseSetByForm.set(form, new Set());
        parseSetByForm.get(form).add(parseKey);
      }
    }
  }

  const unambiguous = [];
  for (const item of uniqueByFormAndParse.values()) {
    const variants = parseSetByForm.get(item.form);
    if (variants && variants.size === 1) unambiguous.push(item);
  }
  return rebalanceByPGN(unambiguous);
}

function buildRecordsFromPayloadRecords(data) {
  const src = Array.isArray(data && data.records) ? data.records : (Array.isArray(data) ? data : []);
  const uniqueByFormAndParse = new Map();
  const parseSetByForm = new Map();

  for (const row of src) {
    if (!row || typeof row !== "object") continue;
    const form = typeof row.form === "string" ? row.form.trim() : "";
    const stem = typeof row.stem === "string" ? row.stem.trim() : "";
    const aspect = typeof row.aspect === "string" ? row.aspect.trim() : "";
    const person = typeof row.person === "string" ? row.person.trim() : "";
    const gender = typeof row.gender === "string" ? row.gender.trim() : "";
    const number = typeof row.number === "string" ? row.number.trim() : "";
    if (!form || !stem || !aspect || !person || !gender || !number) continue;

    const parseKey = [stem, aspect, person, gender, number].join("|");
    const dedupe = `${form}|||${parseKey}`;
    if (!uniqueByFormAndParse.has(dedupe)) {
      uniqueByFormAndParse.set(dedupe, {
        form,
        lexeme: row.lexeme || "",
        verbType: row.verbType || classifyVerbType(row.lexeme || ""),
        stem,
        aspect,
        person,
        gender,
        number
      });
    }
    if (!parseSetByForm.has(form)) parseSetByForm.set(form, new Set());
    parseSetByForm.get(form).add(parseKey);
  }

  const unambiguous = [];
  for (const item of uniqueByFormAndParse.values()) {
    const variants = parseSetByForm.get(item.form);
    if (variants && variants.size === 1) unambiguous.push(item);
  }
  return rebalanceByPGN(unambiguous);
}

function buildRecords(data) {
  if (data && typeof data === "object" && Array.isArray(data.records)) {
    return buildRecordsFromPayloadRecords(data);
  }
  if (Array.isArray(data)) {
    return buildRecordsFromPayloadRecords({ records: data });
  }
  return buildRecordsFromLegacyTop100(data);
}

function buildDeck() {
  const { stem, aspect, verbType } = app.wizardSelection;
  return app.allRecords.filter(r => {
    if (stem.size > 0 && !stem.has(r.stem)) return false;
    if (aspect.size > 0 && !aspect.has(r.aspect)) return false;
    if (verbType.size > 0 && !verbType.has(r.verbType)) return false;
    return true;
  });
}

function setDataStatus(message) {
  void message;
}

function applyDataset(data, sourceLabel) {
  const allowedStems = new Set(STEM_ORDER);
  const parsed = buildRecords(data).filter(r => allowedStems.has(r.stem));
  if (!parsed.length) throw new Error("No parseable forms.");
  app.allRecords = parsed;
  app.options.stem = orderedExisting(STEM_ORDER, app.allRecords.map(r => r.stem));
  app.options.aspect = orderedExisting(ASPECT_ORDER, app.allRecords.map(r => r.aspect));
  app.options.verbType = orderedExisting(ROOT_ORDER, app.allRecords.map(r => r.verbType));

  // Start with nothing selected so users explicitly choose filters.
  app.wizardSelection.stem = new Set();
  app.wizardSelection.aspect = new Set();
  app.wizardSelection.verbType = new Set();
  app.wizardStep = 0;
  app.dataReady = true;
  setDataStatus(`Loaded ${app.allRecords.length} forms from ${sourceLabel}.`);
  renderWizard();
}

function summarizeSet(setRef, allValues, labelFn) {
  if (setRef.size === 0) return "None";
  if (setRef.size === allValues.length) return "All";
  if (setRef.size <= 2) return Array.from(setRef).map(v => labelFn(v)).join(" + ");
  return `${setRef.size} selected`;
}

function renderWizard() {
  if (!app.dataReady) {
    document.getElementById("wizardQuestion").textContent = "Load data to begin.";
    document.getElementById("wizardOptions").innerHTML = "";
    document.getElementById("wizardSummary").innerHTML = "";
    document.getElementById("backBtn").disabled = true;
    document.getElementById("nextBtn").disabled = true;
    return;
  }

  const steps = [
    {
      key: "stem",
      question: "What stem(s) do you want to study?",
      values: app.options.stem,
      display: value => value
    },
    {
      key: "aspect",
      question: "What aspect(s) do you want to study?",
      values: app.options.aspect,
      display: value => value
    },
    {
      key: "verbType",
      question: "What verb type(s) do you want to study?",
      values: app.options.verbType,
      display: value => (ROOT_LABELS[value] || value)
    }
  ];
  const step = steps[app.wizardStep];

  document.getElementById("wizardQuestion").textContent = step.question;

  const optionsEl = document.getElementById("wizardOptions");
  optionsEl.innerHTML = "";
  step.values.forEach(value => {
    const isActive = app.wizardSelection[step.key].has(value);
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = step.display(value);
    if (isActive) btn.classList.add("active");
    btn.onclick = () => {
      if (app.wizardSelection[step.key].has(value)) app.wizardSelection[step.key].delete(value);
      else app.wizardSelection[step.key].add(value);
      renderWizard();
    };
    optionsEl.appendChild(btn);
  });

  document.getElementById("wizardSelectAllBtn").onclick = () => {
    app.wizardSelection[step.key] = new Set(step.values);
    renderWizard();
  };
  document.getElementById("wizardClearBtn").onclick = () => {
    app.wizardSelection[step.key] = new Set();
    renderWizard();
  };

  const summary = document.getElementById("wizardSummary");
  summary.innerHTML = "";
  const deck = buildDeck();
  const pills = [
    `Deck size: ${deck.length}`,
    `Stem: ${summarizeSet(app.wizardSelection.stem, app.options.stem, v => v)}`,
    `Aspect: ${summarizeSet(app.wizardSelection.aspect, app.options.aspect, v => v)}`,
    `Verb type: ${summarizeSet(app.wizardSelection.verbType, app.options.verbType, v => ROOT_LABELS[v] || v)}`
  ];
  pills.forEach(text => {
    const el = document.createElement("span");
    el.textContent = text;
    summary.appendChild(el);
  });

  const note = document.getElementById("wizardNote");
  note.textContent = deck.length ? "" : "No verbs match the current setup.";

  const backBtn = document.getElementById("backBtn");
  const nextBtn = document.getElementById("nextBtn");
  backBtn.disabled = app.wizardStep === 0;

  const hasSelection = app.wizardSelection[step.key].size > 0;
  if (app.wizardStep === steps.length - 1) {
    nextBtn.textContent = "Start Practice";
    nextBtn.disabled = !hasSelection || deck.length === 0;
  } else {
    nextBtn.textContent = "Next";
    nextBtn.disabled = !hasSelection;
  }
}

function renderAnswerButtons(type, values) {
  const container = document.getElementById(type);
  container.innerHTML = "";
  values.forEach(value => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = value;
    if (app.answer[type] === value) btn.className = "active";
    btn.onclick = () => {
      app.answer[type] = value;
      updateConfirmation();
      renderQuizOptions();
    };
    container.appendChild(btn);
  });
}

function renderMobileSelect(type, values, selectId) {
  const select = document.getElementById(selectId);
  if (!select) return;
  select.innerHTML = "";

  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = "Select";
  select.appendChild(placeholder);

  values.forEach(value => {
    const option = document.createElement("option");
    option.value = value;
    option.textContent = value;
    select.appendChild(option);
  });

  select.value = app.answer[type] || "";
}

function renderQuizOptions() {
  renderAnswerButtons("stem", app.options.stem);
  renderAnswerButtons("aspect", app.options.aspect);
  renderAnswerButtons("person", ["1", "2", "3"]);
  renderAnswerButtons("gender", ["Masculine", "Feminine", "Common"]);
  renderAnswerButtons("number", ["Singular", "Plural"]);
  renderMobileSelect("stem", app.options.stem, "mobileStem");
  renderMobileSelect("aspect", app.options.aspect, "mobileAspect");
  renderMobileSelect("person", ["1", "2", "3"], "mobilePerson");
  renderMobileSelect("gender", ["Masculine", "Feminine", "Common"], "mobileGender");
  renderMobileSelect("number", ["Singular", "Plural"], "mobileNumber");
}

function updateConfirmation() {
  const parts = [
    app.answer.stem,
    app.answer.aspect,
    app.answer.person,
    app.answer.gender ? app.answer.gender.toLowerCase() : null,
    app.answer.number ? app.answer.number.toLowerCase() : null
  ].filter(Boolean);
  document.getElementById("confirmation").textContent = parts.length ? parts.join(" · ") : "-";
}

function loadCurrentVerb() {
  const record = app.deck[app.index];
  document.getElementById("hebrew").textContent = record.form;
  document.getElementById("feedback").textContent = "";
  const conf = document.getElementById("confirmation");
  conf.className = "confirmation";

  app.answer = { stem: null, aspect: null, person: null, gender: null, number: null };
  updateConfirmation();
  renderQuizOptions();

  const deckMeta = document.getElementById("deckMeta");
  deckMeta.innerHTML = "";
  const tags = [
    `Set: ${app.deck.length}`,
    `Item: ${app.index + 1}/${app.deck.length}`,
    `Type: ${ROOT_LABELS[record.verbType] || record.verbType}`
  ];
  tags.forEach(t => {
    const el = document.createElement("span");
    el.textContent = t;
    deckMeta.appendChild(el);
  });
}

function submitAnswer() {
  const current = app.deck[app.index];
  if (!current) return;

  const expected = {
    stem: current.stem,
    aspect: current.aspect,
    person: current.person,
    gender: current.gender,
    number: current.number
  };

  const wrong = [];
  for (const key of Object.keys(expected)) {
    if (app.answer[key] !== expected[key]) wrong.push(key);
  }

  const conf = document.getElementById("confirmation");
  const feedback = document.getElementById("feedback");
  conf.classList.remove("correct", "incorrect");

  if (wrong.length === 0) {
    conf.classList.add("correct");
    feedback.textContent = "✓ Correct";
    setTimeout(() => {
      app.index = (app.index + 1) % app.deck.length;
      loadCurrentVerb();
    }, 650);
    return;
  }

  conf.classList.add("incorrect");
  feedback.textContent = wrong.length === 1
    ? `${wrong[0][0].toUpperCase() + wrong[0].slice(1)} is incorrect.`
    : `${wrong.map(k => k[0].toUpperCase() + k.slice(1)).join(" and ")} are incorrect.`;
}

function showQuiz() {
  app.deck = buildDeck();
  if (!app.deck.length) {
    renderWizard();
    return;
  }
  app.index = 0;
  document.getElementById("setupView").classList.add("hidden");
  document.getElementById("quizView").classList.remove("hidden");
  loadCurrentVerb();
}

function showSetup() {
  document.getElementById("quizView").classList.add("hidden");
  document.getElementById("setupView").classList.remove("hidden");
  renderWizard();
}

function wireEvents() {
  const mobileMap = {
    mobileStem: "stem",
    mobileAspect: "aspect",
    mobilePerson: "person",
    mobileGender: "gender",
    mobileNumber: "number"
  };
  Object.entries(mobileMap).forEach(([id, key]) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.onchange = () => {
      app.answer[key] = el.value || null;
      updateConfirmation();
      renderQuizOptions();
    };
  });

  document.getElementById("backBtn").onclick = () => {
    if (app.wizardStep > 0) {
      app.wizardStep -= 1;
      renderWizard();
    }
  };

  document.getElementById("nextBtn").onclick = () => {
    if (app.wizardStep < 2) {
      app.wizardStep += 1;
      renderWizard();
      return;
    }
    showQuiz();
  };

  document.getElementById("submitBtn").onclick = submitAnswer;
  document.getElementById("changeSetupBtn").onclick = showSetup;
}

async function init() {
  wireEvents();
  renderWizard();
  try {
    if (window.HEBREW_VERBS_DATA && typeof window.HEBREW_VERBS_DATA === "object") {
      applyDataset(window.HEBREW_VERBS_DATA, "hebrew_verbs_all_stems.js");
      return;
    }
    if (window.QAL_TOP100_DATA && typeof window.QAL_TOP100_DATA === "object") {
      applyDataset(window.QAL_TOP100_DATA, "qal_strong_top100.js");
      return;
    }
    const res = await fetch("./hebrew_verbs_all_stems.json", { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    applyDataset(data, "hebrew_verbs_all_stems.json");
  } catch (err) {
    try {
      const res = await fetch("./qal_strong_top100.json", { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      applyDataset(data, "qal_strong_top100.json");
      return;
    } catch (_) {}
    setDataStatus("Auto-load failed.");
    document.getElementById("wizardNote").textContent = "Missing data file: hebrew_verbs_all_stems.js (or JSON fallback files).";
  }
}

init();
</script>
</body>
</html>
